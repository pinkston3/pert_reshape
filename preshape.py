import argparse
import os
import re
import sys

import h5py


DEFAULT_FROMDIR = './tmp'
FILE_REGEX = re.compile(r'([^_]*)_eph_g2_p(\d+)\.h5')


class SourceFile:
    '''
    A single source HDF5 file in the source set of data files.
    '''

    def __init__(self, filename: str, pool: int):
        self.filename = filename
        self.pool = pool
        self.hdf5 = None

        # These values are generated by scanning the file
        self.nk_loc = 0
        self.nkq = 0

    def __repr__(self):
        return self.filename

    def scan_contents(self):
        self.hdf5 = h5py.File(self.filename, 'r')
        self.nk_loc = 0
        self.nkq = 0
        while True:
            i = self.nk_loc + 1
            bnd_idx = f'bands_index_{i}'
            eph_g2 = f'eph_g2_{i}'

            if (bnd_idx not in self.hdf5 and eph_g2 not in self.hdf5):
                break

            if ((bnd_idx in self.hdf5 and not eph_g2 in self.hdf5) or
                (bnd_idx not in self.hdf5 and eph_g2 in self.hdf5)):
                raise ValueError(f'Only found one of {bnd_idx} / {eph_g2} in file {self.filename}')

            if len(self.hdf5[bnd_idx]) != len(self.hdf5[eph_g2]):
                raise ValueError(f'Lengths of {bnd_idx} and {eph_g2} differ in file {self.filename}')

            # If we got here then there are no obvious issues with this pair
            # of entries
            self.nk_loc += 1
            self.nkq += len(self.hdf5[bnd_idx])


class SourceFileSet:

    def __init__(self, path):
        self.num_pools = 0
        self.pool_files = {}
        self.prefix = None

        self.nkpt = 0

        self._find_source_files(path)


    def _find_source_files(self, path):
        self.num_pools = 0
        self.pool_files = {}
        self.prefix = None

        files = os.listdir(path)
        for filename in files:
            match = FILE_REGEX.fullmatch(filename)
            if match:
                prefix = match.group(1)
                pool = int(match.group(2))

                if self.prefix is None:
                    self.prefix = prefix
                else:
                    if self.prefix != prefix:
                        raise ValueError(f'File {filename} doesn\'t have expected prefix {self.prefix}')

                if pool in self.pool_files:
                    raise ValueError(f'Pool {pool} appears in multiple filenames')

                self.num_pools += 1
                self.pool_files[pool] = SourceFile(os.path.join(path, filename), pool)

        for i in range(1, self.num_pools + 1):
            if i not in self.pool_files:
                raise ValueError(f'Can\'t find file for pool {i} ,in {self.num_pools} pools')

    def scan_files(self):
        self.nkpt = 0

        print('Scanning source files:')
        for pool in sorted(self.pool_files.keys()):
            f = self.pool_files[pool]
            f.scan_contents()
            print(f' * {f.filename}:\tnk_loc = {f.nk_loc}\tnkq = {f.nkq}')

            self.nkpt += f.nk_loc

        print(f'Total k-grid points found:  {self.nkpt}')



def main():
    parser = argparse.ArgumentParser(prog='preshape',
        description='Reshape Perturbo tmp/ files for a different number of pools')

    parser.add_argument('-f', '--fromdir', default=DEFAULT_FROMDIR,
        help=f'Source directory to read eph_g2_p*.h5 files from.  Default is {DEFAULT_FROMDIR}.')

    parser.add_argument('-t', '--todir', required=True,
        help='Target directory to write reshaped eph_g2_p*.h5 files to.')

    parser.add_argument('-p', '--pools', type=int, required=True,
        help='Number of pools to generate in the target directory.')

    args = parser.parse_args(sys.argv[1:])

    # Check arguments

    print(f'Reading pool files from {args.fromdir}')
    if not os.path.isdir(args.fromdir):
        print(f'ERROR:  {args.fromdir} is not a directory')
        sys.exit(1)

    if args.pools < 1:
        print(f'ERROR:  Number of pools must be positive; got {args.pools}')
        sys.exit(1)

    print(f'Writing {args.pools} pool files to {args.todir}')
    if not os.path.exists(args.todir):
        print(f'NOTE:  {args.todir} doesn\'t exist; creating')
        os.makedirs(args.todir)
    else:
        existing_files = os.listdir(args.todir)
        if len(existing_files) > 0:
            print(f'ERROR:  Existing files found in {args.todir}, aborting.')
            sys.exist(1)

    print(f'Scanning source directory {args.fromdir}')
    sfset = SourceFileSet(args.fromdir)
    print(f'Found {sfset.num_pools} files:')
    for pool in sorted(sfset.pool_files.keys()):
        print(f' * {sfset.pool_files[pool]}')

    sfset.scan_files()

    sys.exit(0)


if __name__ == '__main__':
    main()
