import argparse
import os
import re
import sys

import h5py


DEFAULT_FROMDIR = './tmp'
FILE_REGEX = re.compile(r'([^_]*)_eph_g2_p(\d+)\.h5')


class PoolFile:
    '''
    A single HDF5 file in the set of pool data files.
    '''

    def __init__(self, filename: str, pool: int):
        self.filename = filename
        self.pool = pool
        self.hdf5 = None

        # These values are generated by scanning the file
        self.nk_loc = 0
        self.nkq = 0

    def __repr__(self):
        return self.filename

    def scan_contents(self):
        self.hdf5 = h5py.File(self.filename, 'r')
        self.nk_loc = 0
        self.nkq = 0
        while True:
            i = self.nk_loc + 1
            bnd_idx = f'bands_index_{i}'
            eph_g2 = f'eph_g2_{i}'

            if (bnd_idx not in self.hdf5 and eph_g2 not in self.hdf5):
                break

            if ((bnd_idx in self.hdf5 and not eph_g2 in self.hdf5) or
                (bnd_idx not in self.hdf5 and eph_g2 in self.hdf5)):
                raise ValueError(f'Only found one of {bnd_idx} / {eph_g2} in file {self.filename}')

            if len(self.hdf5[bnd_idx]) != len(self.hdf5[eph_g2]):
                raise ValueError(f'Lengths of {bnd_idx} and {eph_g2} differ in file {self.filename}')

            # If we got here then there are no obvious issues with this pair
            # of entries
            self.nk_loc += 1
            self.nkq += len(self.hdf5[bnd_idx])


class PoolFileSet:
    '''
    A collection of pool data files that drive a Perturbo simulation run.
    '''

    def __init__(self, path):
        self.path = path
        self.num_pools = 0
        self.pool_files = {}
        self.prefix = None
        self.nkpt = 0

    def find_files(self):
        '''
        Scan the file-set's path for pool files.  This is used for the source
        set of data files, but isn't used when generating a new set of data
        files.
        '''
        self.num_pools = 0
        self.pool_files = {}
        self.prefix = None

        files = os.listdir(self.path)
        for filename in files:
            match = FILE_REGEX.fullmatch(filename)
            if match:
                prefix = match.group(1)
                pool = int(match.group(2))

                if self.prefix is None:
                    self.prefix = prefix
                else:
                    if self.prefix != prefix:
                        raise ValueError(f'File {filename} doesn\'t have expected prefix {self.prefix}')

                if pool in self.pool_files:
                    raise ValueError(f'Pool {pool} appears in multiple filenames')

                self.num_pools += 1
                self.pool_files[pool] = PoolFile(os.path.join(self.path, filename), pool)

        for i in range(1, self.num_pools + 1):
            if i not in self.pool_files:
                raise ValueError(f'Can\'t find file for pool {i} ,in {self.num_pools} pools')

    def scan_files(self):
        self.nkpt = 0

        for pool in sorted(self.pool_files.keys()):
            f = self.pool_files[pool]
            f.scan_contents()
            self.nkpt += f.nk_loc


def main():
    parser = argparse.ArgumentParser(prog='preshape',
        description='Reshape Perturbo tmp/ files for a different number of pools')

    parser.add_argument('-f', '--fromdir', default=DEFAULT_FROMDIR,
        help=f'Source directory to read eph_g2_p*.h5 files from.  Default is {DEFAULT_FROMDIR}.')

    parser.add_argument('-t', '--todir', required=True,
        help='Target directory to write reshaped eph_g2_p*.h5 files to.')

    parser.add_argument('-p', '--pools', type=int, required=True,
        help='Number of pools to generate in the target directory.')

    args = parser.parse_args(sys.argv[1:])

    # Check arguments

    print(f'Reading pool files from {args.fromdir}')
    if not os.path.isdir(args.fromdir):
        print(f'ERROR:  {args.fromdir} is not a directory')
        sys.exit(1)

    if args.pools < 1:
        print(f'ERROR:  Number of pools must be positive; got {args.pools}')
        sys.exit(1)

    print(f'Writing {args.pools} pool files to {args.todir}')
    if not os.path.exists(args.todir):
        print(f'NOTE:  {args.todir} doesn\'t exist; creating')
        os.makedirs(args.todir)
    else:
        existing_files = os.listdir(args.todir)
        if len(existing_files) > 0:
            print(f'ERROR:  Existing files found in {args.todir}, aborting.')
            sys.exist(1)

    print(f'\nScanning source directory {args.fromdir}')

    sfset = PoolFileSet(args.fromdir)
    sfset.find_files()
    sfset.scan_files()

    print(f'Found {sfset.num_pools} files:')
    for pool in sorted(sfset.pool_files.keys()):
        f = sfset.pool_files[pool]
        print(f' * {f.filename}:\tnk_loc = {f.nk_loc}\tnkq = {f.nkq}')

    print(f'Total k-grid points found:  {sfset.nkpt}')


    sys.exit(0)


if __name__ == '__main__':
    main()
